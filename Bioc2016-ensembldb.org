#+TITLE: Building and Using Ensembl-based Annotation Packages with ensembldb
#+AUTHOR: Johannes Rainer
#+EMAIL: johannes.rainer@eurac.edu
#+DATE: June 26, 2016
#+SETUPFILE: orgsetup.org
#+STARTUP: overview
#+STARTUP: indent

* Building and Using Ensembl-based Annotation Packages with =ensembldb=

*Johannes Rainer* (EURAC), BioC 2016 Stanford

Clone me: http://github.com/jotsetung/Bioc2016-ensembldb.

** Introduction

+ =TxDb= objects from =GenomicFeatures= provide gene model annotations.
+ =ensembldb= package defines =EnsDb= class also providing gene models.
+ =EnsDB= object/database:
  - Designed for Ensembl annotations: new attributes /gene biotype/ and /tx biotype./
  - Allows to query specific annotations using a simple *filter framework*.
  - Methods allow to specify the type of the returned object.
  - Interchangeable with =TxDb= objects.
  - Support =AnnotationDbi='s =select= method.

** Usage

*** Query gene, transcript, exon information

+ =EnsDb= objects can be used just like =TxDb= objects.
+ Available methods:
  - =genes=
  - =transcripts=
  - =transcriptsBy=
  - =exons=
  - =exonsBy=
  - =cdsBy=
  - =fiveUTRsByTranscripts=
  - =threeUTRsByTranscripts=
+ _Example_: get genes and transcript data.

  #+BEGIN_SRC R
    ## Load an EnsDb package matching Ensembl version 81
    library(EnsDb.Hsapiens.v81)
    edb <- EnsDb.Hsapiens.v81

    ## Now just get all genes
    genes(edb)

    ## Alternatively, we can specify to return the results as DataFrame
    transcripts(edb, return.type="DataFrame")
  #+END_SRC
+ _Example_: Use filters to fetch specific information.

  #+BEGIN_SRC R
    ####
    ## Task: retrieve genes encoded on chromosome Y.
    ## Create a filter object
    sf <- SeqnameFilter("Y")

    ## Retrieve the data
    genes(edb, filter=sf)

  #+END_SRC

*** Supported filters

- For genes:
  + =GeneidFilter=
  + =GenenameFilter=
  + =EntrezidFilter=
  + =GenebiotypeFilter=
- For transcripts:
  + =TxidFilter=
  + =TxbiotypeFilter=
- For exons:
  + =ExonidFilter=
  + =ExonrankFilter=
- /Generic/ filters:
  + =SeqnameFilter=
  + =SeqstrandFilter=
  + =SeqstartFilter=
  + =SeqendFilter=
  + =GRangesFilter=: condition can be /within/ or /overlapping/.

- Multiple filters can be combined with a logical /AND/.
- Each filter supports 1:n values and also a /like/ condition.
- _Example_: combine filters.

  #+BEGIN_SRC R
    ####
    ## Example for a GRangesFilter
    ## 'condition' could be "within" or "overlapping"
    grf <- GRangesFilter(GRanges(17, IRanges(59000000, 59200000)),
                         condition="within")

    ## Get all genes encoded in this retion.
    genes(edb, filter=grf, columns=c("gene_name", "gene_biotype"))

    ####
    ## Combine filters: add a GenebiotypeFilter
    ## List all available gene biotypes:
    listGenebiotypes(edb)
    ## Get all genes in the region except pre-miRNAs and snRNAs.
    genes(edb, filter=list(grf,
                           GenebiotypeFilter(c("miRNA", "snRNA"),
                                             condition="!=")))

  #+END_SRC

*** Annotation for feature counting

+ =EnsDb= databases can also provide gene model information for feature counting.
+ In combination with =summarizeOverlaps= from the =GenomicAlignments= package.
+ _Example_: get gene models for feature counting with =summarizeOverlaps=.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Get exons by gene, for chromosomes 1:22, X, Y, excluding also locus reference
    ## genomic genes (LRG)
    exns <- exonsBy(edb, by="gene", filter=list(SeqnameFilter(c(1:22, "X", "Y")),
                                                GeneidFilter("ENSG%", "like")))
    exns

    ## Load the required libraries.
    library(GenomicAlignments)
    library(BiocParallel)

    ## Get the Bam files.
    bfl <- BamFileList(dir("data/bam", pattern=".bam$", full.names=TRUE),
                       asMates=TRUE, yieldSize=1e+6, obeyQname=TRUE)
    ## Define a ScanBamParam with a mapping quality filter.
    sbp <- ScanBamParam(mapqFilter=30)

    ## Do the gene counting
    geneCounts <- bplapply(bfl, FUN=summarizeOverlaps, features=exns,
                           mode="IntersectionStrict", ignore.strand=TRUE,
                           singleEnd=FALSE, fragments=TRUE, param=sbp)
    geneCounts <- do.call(cbind, geneCounts)


  #+END_SRC

+ In combination with =Rsubread='s =featureCount= function.
+ _Example_: gene models for =featureCount=.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Convert the exon list to SAF format
    saf <- toSAF(exns)

    head(saf)

    ####
    ##  Do the feature counting using the Rsubread package
    library(Rsubread)
    bamf <- dir("data/bam", pattern=".bam$", full.names=TRUE)
    cnts <- featureCounts(files=bamf, annot.ext=saf, isPairedEnd=TRUE, nthreads=1)

  #+END_SRC

*** Get genomic or transcript sequences

+ =BSGenome= packages provide genomic sequence for a variety of species.
+ Most are based on UCSC data, that use different genome
  release names than Ensembl (e.g. /hg19/ instead of /GRCh37/) and have a different
  chromosome naming style.
+ _Example_: get mRNA sequences for a gene's transcripts.

  #+BEGIN_SRC R
    ## Get the genome and Ensembl version of the package:
    unique(genome(edb))
    ensemblVersion(edb)

    ## Where to get this genome sequence? Answer: AnnotationHub!
    library(AnnotationHub)
    ah <- AnnotationHub()
    ## Search for all human Ensembl files for release 81.
    query(ah, pattern=c("Ensembl", "homo sapiens", "81"))

    ## So we've got the genomic DNA sequence matching that version.
    fafile <- ah[["AH49186"]]

    ## Easier/better way: use the dedicated 'getGenomeFaFile' method
    fafile <- getGenomeFaFile(edb)

    ## Task: get transcript sequences for SKA2
    ## 1) Get all exons by transcript.
    ska2Txs <- exonsBy(edb, by="tx", filter=GenenameFilter("SKA2"))

    ## 2) Use GenomicFeatures' extractTranscriptSeqs method.
    txSeqs <- extractTranscriptSeqs(fafile, ska2Txs)
    txSeqs

    ## Alternative: use getSeq
    library(Biostrings)
    getSeq(fafile, ska2Txs[[1]])

  #+END_SRC

+ That's convenient, especially if we're using an =EnsDb= for a non-standard
  organism.
+ *But*: wouldn't it be nice to use =BSGenome= packages?
+ _Example_: use =EnsDb= with UCSC style chromosome names.

  #+BEGIN_SRC R
    library(BSgenome.Hsapiens.UCSC.hg38)

    tryCatch(
        extractTranscriptSeqs(BSgenome.Hsapiens.UCSC.hg38, ska2Txs)
    )

    ## Doesn't work, because of different chromosome naming.
    head(seqlevels(BSgenome.Hsapiens.UCSC.hg38))
    head(seqlevels(edb))

    ## Solution: change the seqlevel style of the EnsDb!
    seqlevelsStyle(edb) <- "UCSC"

    head(seqlevels(edb))

    ## Now we can use UCSC chromosome names:
    genes(edb, filter=SeqnameFilter("chrY"))

    ## Get the exons by gene.
    ska2Txs <- exonsBy(edb, filter=GenenameFilter("SKA2"))

    ## Get the tx sequence using the BSgenome package.
    extractTranscriptSeqs(BSgenome.Hsapiens.UCSC.hg38, ska2Txs)

    ## Compare to the FaFile from Ensembl.
    txSeqs

    ## Change back, so we don't break following examples.
    seqlevelsStyle(edb) <- "Ensembl"
  #+END_SRC

+ Sequence names are mapped between /styles/ using the =GenomeInfoDb= package.

*** Plotting

+ =ggbio=: we can directly pass =EnsDb= objects and filters to the functions.
+ _Example_: use =ggbio= and =ensembldb= to plot a chromosomal region.

  #+NAME: usage-ggbio
  #+BEGIN_SRC R :results output graphics :file ggbio-ska2.pdf :exports both :width 8 :height 6
    library(ggbio)

    ## Plot the SKA2 gene model by passing a filter to the function.
    autoplot(edb, GenenameFilter("SKA2"))

    ## To plot all genes in the region:
    ## Get the gene SKA2
    ska2 <- genes(edb, filter=GenenameFilter("SKA2"))
    strand(ska2) <- "*"

    ## Plot the genomic region; we're using the gene name as labels for the transcripts.
    autoplot(edb, GRangesFilter(ska2, condition="overlapping"),
             names.expr="gene_name")

  #+END_SRC

+ =Gviz=: =getGeneRegionTrackForGviz= method to extract data formatted for =Gviz=.
+ _Example_: plot genes encoded on a chromosomal region using =Gviz=.

  #+NAME: usage-gviz
  #+BEGIN_SRC R :results output graphics :file gviz-ska.pdf :exports both :width 8 :height 6
    library(Gviz)

    ## Get all genes in the same genomic region and return as GRanges
    ## formatted for Gviz.
    grt <- getGeneRegionTrackForGviz(edb, chromosome=seqlevels(ska2),
                                     start=start(ska2), end=end(ska2))
    ## Alternatively, using a GRangesFilter
    strand(ska2) <- "*"
    grt <- getGeneRegionTrackForGviz(edb, filter=GRangesFilter(ska2,
                                                               condition="overlapping"))

    geneTrack <- GeneRegionTrack(grt)
    ## Plot the chromosomal region.
    plotTracks(list(GenomeAxisTrack(), geneTrack), transcriptAnnotation="symbol",
               chromosome=seqlevels(ska2))
  #+END_SRC

*** =ensembldb= and the =AnnotationDbi= API

+ =AnnotationDbi= defines methods =columns=, =keys=, =keytypes=, =mapIds= and =select=.
+ =EnsDb= support all these methods which can be combined with /filters/.
+ _Example_: use methods from the =AnnotationDbi= API to fetch annotations.

  #+BEGIN_SRC R
    ## What keytypes can be used
    keytypes(edb)

    ## List all tx keys (tx_id)
    head(keys(edb, keytype="TXID"))

    ## Note that we can again use filters here:
    txKeys <- keys(edb, keytype="TXID", filter=GenenameFilter("SKA2"))
    txKeys

    ## We could use these keys in the select call or alternatively
    ## pass the filter(s) directly with argument 'key'.
    select(edb, keys=list(GenenameFilter("SKA2"),
                          TxbiotypeFilter("nonsense_mediated_decay")))

  #+END_SRC

*** The =ensembldb= shiny app

+ A =shiny= app is also available for =EnsDb= objects, start it with =runEnsDbApp=.
+ _Example_: search for a gene using the shiny app and return the result to R.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Run the shiny app:
    Result <- runEnsDbApp()

    ## Inspect the result:
    Result
#+END_SRC

** Building annotation databases

+ Ensembl, Ensembl Genomes and Ensembl Plants provide annotations for a large
  number of species. All follow the same database scheme.

*** The hard way: with Ensembl's Perl API

+ Requires:
  - Ensembl Perl API (and Bioperl).
  - =PERL5LIB= environment variable should point to the API version matching the
    Ensembl version that should be queried.
+ =fetchTablesFromEnsembl= to fetch the annotations from Ensembl.
+ =makeEnsemblSQLiteFromTables= to create the SQLite database from the tables.
+ =makeEnsembldbPackage= to create a package containing and providing the
  annotation.
+ _Example_: create an =EnsDb= using the Perl API.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Create an EnsDb using the Ensembl Perl API:

    ## This takes quite some time...
    fetchTablesFromEnsembl(version="81",
                           ensemblapi="/Users/jo/ensembl/81/API/ensembl/modules",
                           species="dog")

    ## Create an SQLite database from the generated txt files
    dbf <- makeEnsemblSQLiteFromTables()

    ## Finally, create the package
    makeEnsembldbPackage(ensdb=dbf, version="1.0.0",
                         maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                         author="Johannes Rainer")
  #+END_SRC

*** The easy way: from gtf and gff files

+ Easier and faster way: create an =EnsDb= from a /gtf/ or /gff/ file.
+ /Should/ work with all gtf and gff files from Ensembl.
+ Gtf files don't provide the Entrez IDs, database column will thus be empty.
+ _Example_: create an =EnsDb= from a GTF file downloaded from ftp://ftp.ensembl.org.

  #+BEGIN_SRC R :eval never
    ## Create an EnsDb from a GTF file from Ensembl.

    ## Create the SQLite database file:
    ##  o Eventually define 'organism' and 'genomeVersion'.
    ##  o Needs also an internet connection to retrieve the 'seqlengths'.
    edbSql <- ensDbFromGtf("data/gtf/Canis_familiaris.CanFam3.1.84.gtf.gz")

    edbSql

    ## Use the makeEnsembldbPackage to create a package, or load and use it.
    dogDb <- EnsDb(edbSql)

    dogDb

    ## Fully functional, except we don't have Entrez gene ids.
    head(genes(dogDb, filter=SeqnameFilter("X")))
  #+END_SRC

*** Even easier: use =AnnotationHub=

+ We can build an =EnsDb= from an =AnnotationHub= resource or a =GRanges= object.
+ _Example_: create an =EnsDb= using =AnnotationHub=.

  #+BEGIN_SRC R :results silent :exports code :eval never
    ## Create an EnsDb from a GRanges retrieved from AnnotationHub.

    library(AnnotationHub)
    ah <- AnnotationHub()

    ## Query for available Ensembl files matching homo sapiens and 83
    query(ah, pattern=c("ensembl", "83", "gtf"))

    ## Select one; in this case: Tupaia_belangeri (treeshew).
    edbSql83 <- ensDbFromAH(ah=ah["AH50415"])

    ## Make a package from that.
    makeEnsembldbPackage(ensdb=edbSql83, version="1.0.0",
                         maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                         author="J Rainer")



    ## Alternatively, we could build the EnsDb from a GRanges object
    ## providing the required columns/attributes.
    ensGr <- ah[["AH50415"]]

    ensGr

    ## Create a EnsDb from that GRanges
    ##  o have to provide organism, genome version and (Ensembl) version
    edbSql83 <- ensDbFromGRanges(ensGr, organism=ah["AH50415"]$species, version="83",
                                 genomeVersion=ah["AH50415"]$species)
  #+END_SRC

** Some internals on the filter framework

+ How does the filter framework work?
+ _Example_: =column= and =where= methods of a =GenenameFilter=.

  #+NAME: internals-filter
  #+BEGIN_SRC R
    ## Create a simple GenenameFilter
    gnf <- GenenameFilter("SKA2")

    gnf

    ## 'column' and 'where' methods.
    ensembldb:::column(gnf)
    ## The 'where' condition for the SQL call
    where(gnf)

    ## These are conditional on the database object
    ensembldb:::column(gnf, edb)
    where(gnf, edb)
  #+END_SRC

+ =column= method is used to define which columns are required from the database.
+ =where= method is used to build the /where/ condition of the SQL call.
+ Implementing these methods for other database objects enables reuse of the
  classes in other packages.


** Other packages using/extending the =ensembldb= filter framework

+ =mirhostgenes= R-package (https://github.com/jotsetung/mirhostgenes): predicts
  host genes (primary transcription units) of miRNAs based on genomic
  alignment of pre-miRNAs.
+ Imports all filter objects from =ensembldb=.
+ _Example_: get all miRNAs potentially encoded in the same primary transcript
  than SKA2.

  #+NAME: other-packages-mirhostgene-concept
  #+BEGIN_SRC R :results output graphics :file mirna-ska2.pdf :exports both
    ## Plot the genomic region in which SKA2 is encoded to illustrate the
    ## host gene prediction.
    library(Gviz)
    ska2 <- genes(edb, filter=gnf)
    chromReg <- getGeneRegionTrackForGviz(edb, chromosome=seqlevels(ska2),
                                          start=start(ska2), end=end(ska2))
    geneTrack <- GeneRegionTrack(chromReg)
    plotTracks(geneTrack, transcriptAnnotation="symbol")
    ## Two miRNAs are encoded in the first exon of SKA2.

  #+END_SRC

  #+NAME: other-packages-mirhostgenes
  #+BEGIN_SRC R
    ## Load a database defining predicted miRNA host genes for miRBase 21.
    library(mirhostgenes)
    library(MirhostDb.Hsapiens.v81.v21)
    mhdb <- MirhostDb.Hsapiens.v81.v21

    ## Re-use the GenenameFilter
    where(gnf, mhdb)

    ## Get all mature miRNAs that could be encoded in a common primary transcript.
    matmirnas(mhdb, filter=gnf)

  #+END_SRC

+ miRNA target genes: =mirtarbase= package
  (https://github.com/jotsetung/mirtarbase), bases on data from miRTarBase
  (http://mirtarbase.mbc.nctu.edu.tw/).
+ All miRNA-target gene interactions (MTIs) for all species derived from
  literature.
+ Imports all filter classes from =ensembldb= and =mirhostgenes=.
+ _Example_: get all miRNAs targeting SKA2 and all target genes of miR-301a-3p.

  #+NAME: other-packages-mirtarbase
  #+BEGIN_SRC R
    ####
    ## Load the mirtarbase library providing validated target genes
    library(mirtarbase)

    ## Target genes are categorized by 'Support type'
    listSupportTypes(mirtarbase)

    ## Re-use the GenenameFilter
    where(gnf, mirtarbase)

    ## Get all miRNA-target gene interactions for SKA2.
    miRs <- mtis(mirtarbase, filter=gnf)
    miRs

    ## What miRNAs have been shown to regulate SKA2?
    matmirna(miRs)

  #+END_SRC

+ Both packages are still in development.






