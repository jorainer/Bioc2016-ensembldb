#+TITLE: Building and Using Ensembl-based Annotation Packages with ensembldb
#+AUTHOR: Johannes Rainer
#+EMAIL: johannes.rainer@eurac.edu
#+DATE: June 26, 2016
#+SETUPFILE: orgsetup.org
#+STARTUP: overview
#+STARTUP: indent

* Building and Using Ensembl-based Annotation Packages with =ensembldb=

*Johannes Rainer* (EURAC), BioC 2016 Stanford

Clone me @github: http://github.com/jotsetung/Bioc2016-ensembldb.

** Introduction

+ =TxDb= objects from =GenomicFeatures= provide gene model annotations.
+ =ensembldb= package defines =EnsDb= class also providing gene models.
+ =EnsDB= object/database:
  - Designed for Ensembl annotations: *all* genes, new attributes /gene biotype/ and
    /tx biotype./
  - Allows to query specific annotations using a simple *filter framework*.
  - Methods allow to specify the type of the returned object.
  - Interchangeable with =TxDb= objects.


** Usage

*** Query gene, transcript, exon information

+ =EnsDb= objects can be used just like =TxDb= objects.
+ Available methods to extract data:
  - =genes=
  - =transcripts=
  - =transcriptsBy=
  - =exons=
  - =exonsBy=
  - =cdsBy=
  - =fiveUTRsByTranscripts=
  - =threeUTRsByTranscripts=
+ _Example_: get genes and transcripts.

  #+BEGIN_SRC R
    ## Load an EnsDb package matching Ensembl version 81
    library(EnsDb.Hsapiens.v81)
    edb <- EnsDb.Hsapiens.v81

    ## Now just get all genes
    genes(edb)

    ## Alternatively, we can specify to return the results as DataFrame
    transcripts(edb, return.type="DataFrame")
  #+END_SRC
+ _Example_: Use filters to fetch specific information.

  #+BEGIN_SRC R
    ## Task: retrieve genes encoded on chromosome Y.
    ## Create a filter object
    sf <- SeqnameFilter("Y")

    ## Retrieve the data
    genes(edb, filter=sf)

  #+END_SRC

*** Available filters

- For genes:
  + =GeneidFilter=
  + =GenenameFilter=
  + =EntrezidFilter=
  + =GenebiotypeFilter=
- For transcripts:
  + =TxidFilter=
  + =TxbiotypeFilter=
- For exons:
  + =ExonidFilter=
  + =ExonrankFilter=
- /Generic/ filters:
  + =SeqnameFilter=
  + =SeqstrandFilter=
  + =SeqstartFilter=
  + =SeqendFilter=
  + =GRangesFilter=: condition can be /within/ or /overlapping/.

- Use of filters can speed up queries.
- Multiple filters can be combined with a logical /AND/.
- Each filter supports 1:n values and also a /like/ condition.
- _Example_: combine filters.

  #+BEGIN_SRC R
    ## Example for a GRangesFilter
    ## 'condition' could be "within" or "overlapping"
    grf <- GRangesFilter(GRanges(17, IRanges(59000000, 59200000)),
                         condition="within")

    ## Get all genes encoded in this region.
    genes(edb, filter=grf, columns=c("gene_name", "gene_biotype"))

    ## Combine with a GenebiotypeFilter to get all genes in the region
    ## EXCEPT pre-miRNAs and snRNAs.
    genes(edb, filter=list(grf,
                           GenebiotypeFilter(c("miRNA", "snRNA"),
                                             condition="!=")))

    ## Use the listGenbiotypes and listTxbiotypes to get an overview
    ## of available biotypes.
    listGenebiotypes(edb)

  #+END_SRC

*** =ensembldb= and the =AnnotationDbi= API

+ =AnnotationDbi= defines methods =columns=, =keys=, =keytypes=, =mapIds= and =select=.
+ =EnsDb= support all these methods *with filters*.
+ _Example_: use methods from the =AnnotationDbi= API to fetch annotations.

  #+BEGIN_SRC R
    ## Get all data for the gene SKA2
    select(edb, keys="SKA2", keytype="GENENAME")

    ## What 'keytypes' are supported by EnsDb?
    keytypes(edb)

    ## Or: pass filters with keys parameter to
    ## have more control:
    ## All exons except exons 1 and 2 for all transcripts targeted for
    ## nonsense mediated decay for the gene SKA2.
    select(edb, keys=list(GenenameFilter("SKA2"),
                          TxbiotypeFilter("nonsense_mediated_decay"),
                          ExonrankFilter(1:2, condition="!=")))

  #+END_SRC

*** Annotation for feature counting

+ =EnsDb= provide gene model information for feature counting: =exonsBy= method.

+ _Example_: get gene models for feature counting with =summarizeOverlaps= from the
  =GenomicAlignments= package.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Get exons by gene, for chromosomes 1:22, X, Y, excluding also locus reference
    ## genomic genes (LRG)
    exns <- exonsBy(edb, by="gene", filter=list(SeqnameFilter(c(1:22, "X", "Y")),
                                                GeneidFilter("ENSG%", "like")))
    exns

    ## Load the required libraries.
    library(GenomicAlignments)
    library(BiocParallel)

    ## Get the Bam files.
    bfl <- BamFileList(dir("data/bam", pattern=".bam$", full.names=TRUE),
                       asMates=TRUE, yieldSize=1e+6, obeyQname=TRUE)
    ## Define a ScanBamParam with a mapping quality filter.
    sbp <- ScanBamParam(mapqFilter=30)

    ## Do the gene counting
    geneCounts <- bplapply(bfl, FUN=summarizeOverlaps, features=exns,
                           mode="IntersectionStrict", ignore.strand=TRUE,
                           singleEnd=FALSE, fragments=TRUE, param=sbp)
    geneCounts <- do.call(cbind, geneCounts)


  #+END_SRC

+ _Example_: gene models for =Rsubread='2 =featureCount= function.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Convert the exon list to SAF format
    saf <- toSAF(exns)

    head(saf)

    ####
    ##  Do the feature counting using the Rsubread package
    library(Rsubread)
    bamf <- dir("data/bam", pattern=".bam$", full.names=TRUE)
    cnts <- featureCounts(files=bamf, annot.ext=saf, isPairedEnd=TRUE, nthreads=1)

  #+END_SRC

*** Integrating UCSC and Ensembl annotations

+ _Example_: How to integrate Ensembl based annotation with UCSC data.

#+BEGIN_SRC R
  ## Get chromosome names
  head(seqlevels(edb))
  ## Different from UCSC style: chr1...

  ## Get genes on chromosome Y.
  genes(edb, filter=SeqnameFilter("chrY"))

  ## Solution: change the chromosome naming style:
  seqlevelsStyle(edb) <- "UCSC"

  ## Get chromosome names
  head(seqlevels(edb))

  genes(edb, filter=SeqnameFilter("chrY"))


  ## Example: get mRNA sequences for SKA2 using BSgenome.
  library(BSgenome.Hsapiens.UCSC.hg38)  ## <- UCSC based

  ## Get exons by transcript
  ska2tx <- exonsBy(edb, by="tx", filter=GenenameFilter("SKA2"))

  ## Use GenomicFeatures' extractTranscriptSeqs
  extractTranscriptSeqs(BSgenome.Hsapiens.UCSC.hg38, ska2tx)


  ## Alternative (preferred way):
  seqlevelsStyle(edb) <- "Ensembl"
  ## Using AnnotationHub:
  ## Get the genomic fasta file matching the package's genome version:
  faf <- getGenomeFaFile(edb)

  extractTranscriptSeqs(faf, exonsBy(edb, by="tx",
                                     filter=GenenameFilter("SKA2")))
#+END_SRC

+ Sequence names are mapped between /styles/ using the =GenomeInfoDb= package.

*** Plot gene models using =ensembldb=

+ =ggbio=: support for =EnsDb= objects *and filters* integrated.
+ _Example_: use =ggbio= and =ensembldb= to plot a chromosomal region.

  #+NAME: usage-ggbio
  #+BEGIN_SRC R :results output graphics :file ggbio-ska2.pdf :exports both :width 8 :height 6
    library(ggbio)

    ## Plot the SKA2 gene model by passing a filter to the function.
    autoplot(edb, GenenameFilter("SKA2"))

    ## To plot all genes in the region:
    ## Get the gene SKA2
    ska2 <- genes(edb, filter=GenenameFilter("SKA2"))
    strand(ska2) <- "*"

    ## Plot the genomic region; we're using the gene name as labels for the transcripts.
    autoplot(edb, GRangesFilter(ska2, condition="overlapping"),
             names.expr="gene_name")

  #+END_SRC

+ =Gviz=: =getGeneRegionTrackForGviz= method to extract data formatted for =Gviz=.
+ _Example_: plot genes encoded on a chromosomal region using =Gviz=.

  #+NAME: usage-gviz
  #+BEGIN_SRC R :results output graphics :file gviz-ska.pdf :exports both :width 8 :height 6
    library(Gviz)

    ## Get all genes in the same genomic region and return as GRanges
    ## formatted for Gviz.
    grt <- getGeneRegionTrackForGviz(edb, chromosome=seqlevels(ska2),
                                     start=start(ska2), end=end(ska2))
    ## Alternatively, using a GRangesFilter
    strand(ska2) <- "*"
    grt <- getGeneRegionTrackForGviz(edb, filter=GRangesFilter(ska2,
                                                               condition="overlapping"))

    geneTrack <- GeneRegionTrack(grt)
    ## Plot the chromosomal region.
    plotTracks(list(GenomeAxisTrack(), geneTrack), transcriptAnnotation="symbol",
               chromosome=seqlevels(ska2))
  #+END_SRC

*** The =ensembldb= shiny app

+ A =shiny= app is also available for =EnsDb= objects, start it with =runEnsDbApp=.
+ _Example_: search for a gene using the shiny app and return the result to R.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Run the shiny app:
    Result <- runEnsDbApp()

    ## Inspect the result:
    Result
#+END_SRC


** Building annotation databases

+ Ensembl, Ensembl Genomes and Ensembl Plants provide annotations for a large
  number of species. All follow the same database scheme.

*** The hard way: with Ensembl's Perl API

+ Requires:
  - Ensembl Perl API (and Bioperl).
  - =PERL5LIB= environment variable should point to the API version matching the
    Ensembl version that should be queried.
+ =fetchTablesFromEnsembl= to fetch the annotations from Ensembl.
+ =makeEnsemblSQLiteFromTables= to create the SQLite database from the tables.
+ =makeEnsembldbPackage= to create a package containing and providing the
  annotation.
+ _Example_: create an =EnsDb= using the Perl API.

  #+BEGIN_SRC R :eval never :ravel eval=FALSE
    ## Create an EnsDb using the Ensembl Perl API:

    ## This takes quite some time...
    fetchTablesFromEnsembl(version="81",
                           ensemblapi="/Users/jo/ensembl/81/API/ensembl/modules",
                           species="dog")

    ## Create an SQLite database from the generated txt files
    dbf <- makeEnsemblSQLiteFromTables()

    ## Finally, create the package
    makeEnsembldbPackage(ensdb=dbf, version="1.0.0",
                         maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                         author="Johannes Rainer")
  #+END_SRC

*** The easy way: from gtf and gff files

+ =ensDbFromGtf=: create an =EnsDb= from a /gtf/ or /gff/ file.
+ /Should/ work with all gtf and gff files from Ensembl.
+ *But*: gtf files don't provide Entrez Gene IDs.
+ _Example_: create an =EnsDb= from a GTF file downloaded from ftp://ftp.ensembl.org.

  #+BEGIN_SRC R :eval never
    ## Create an EnsDb from an Ensembl GTF file.

    ## Create the SQLite database file:
    ##  o Eventually define 'organism' and 'genomeVersion'.
    ##  o Needs also an internet connection to retrieve the 'seqlengths'.
    edbSql <- ensDbFromGtf("data/gtf/Canis_familiaris.CanFam3.1.84.gtf.gz")

    edbSql

    ## Use the makeEnsembldbPackage to create a package, or load and use it.
    dogDb <- EnsDb(edbSql)

    dogDb

    ## Fully functional, except we don't have Entrez gene ids.
    head(genes(dogDb, filter=SeqnameFilter("X")))
  #+END_SRC

*** Even easier: use =AnnotationHub=

+ =ensDbFromAH=: build an =EnsDb= from an =AnnotationHub= resource.
+ _Example_: create an =EnsDb= using =AnnotationHub=.

  #+BEGIN_SRC R :results silent :exports code :eval never
    ## Create an EnsDb from a GRanges retrieved from AnnotationHub.

    library(AnnotationHub)
    ah <- AnnotationHub()

    ## Query for available Ensembl gtf files for release 83.
    query(ah, pattern=c("ensembl", "83", "gtf"))

    ## Select one; in this case: Anolis carolinensis (lizard)
    edbSql83 <- ensDbFromAH(ah=ah["AH7537"])

    ## Let's see what we've got.
    db <- EnsDb(edbSql83)
    genes(db)

    ## Make a package.
    makeEnsembldbPackage(ensdb=edbSql83, version="1.0.0",
                         maintainer="Johannes Rainer <johannes.rainer@eurac.edu>",
                         author="J Rainer")

  #+END_SRC

+ Again: no NCBI Entrez Gene IDs available.


** Some internals on the filter framework

+ How does the filter framework work?
+ _Example_: =column= and =where= methods of a =GenenameFilter=.

  #+BEGIN_SRC R
    ## Create a simple GenenameFilter
    gnf <- GenenameFilter("SKA2")

    ## 'column' and 'where' methods.
    ensembldb:::column(gnf)
    ## The 'where' condition for the SQL call
    where(gnf)

    ## These are conditional on the database object
    ensembldb:::column(gnf, edb)
    where(gnf, edb)
  #+END_SRC

+ =column= method is used to define which columns are required from the database.
+ =where= method is used to build the /where/ condition of the SQL call.
+ Implementing these methods for other database objects enables reuse of the
  classes in other packages.
+ _Example_: implementation in the =mirtarbase= package.
  - https://github.com/jotsetung/mirtarbase
  - Bases on the miRTarBase data: validated miRNA target genes
    (http://mirtarbase.mbc.nctu.edu.tw/).

  #+BEGIN_SRC R
    ## Load the library.
    library(mirtarbase)

    ## where condition for the GenenameFilter in the mirtarbase:
    where(gnf, mirtarbase)

    ## Get all miRNAs that have been reported to regulate SKA2
    ska2mirs <- mtis(mirtarbase, filter=gnf)
    ska2mirs

    ## Get the mature miRNA ID
    matmirna(ska2mirs)

    ## Get the PubMed ID of the reports.
    pmid(ska2mirs)
  #+END_SRC


** Finally...


*Thank you for your attention!*



** Other packages using/extending the =ensembldb= filter framework   :ARCHIVE:

+ =mirhostgenes= R-package (https://github.com/jotsetung/mirhostgenes): predicts
  host genes (primary transcription units) of miRNAs based on genomic
  alignment of pre-miRNAs.
+ Imports all filter objects from =ensembldb=.
+ _Example_: get all miRNAs potentially encoded in the same primary transcript
  than SKA2.

  #+NAME: other-packages-mirhostgene-concept
  #+BEGIN_SRC R :results output graphics :file mirna-ska2.pdf :exports both
    ## Plot the genomic region in which SKA2 is encoded to illustrate the
    ## host gene prediction.
    library(Gviz)
    ska2 <- genes(edb, filter=gnf)
    chromReg <- getGeneRegionTrackForGviz(edb, chromosome=seqlevels(ska2),
                                          start=start(ska2), end=end(ska2))
    geneTrack <- GeneRegionTrack(chromReg)
    plotTracks(geneTrack, transcriptAnnotation="symbol")
    ## Two miRNAs are encoded in the first exon of SKA2.

  #+END_SRC

  #+NAME: other-packages-mirhostgenes
  #+BEGIN_SRC R
    ## Load a database defining predicted miRNA host genes for miRBase 21.
    library(mirhostgenes)
    library(MirhostDb.Hsapiens.v81.v21)
    mhdb <- MirhostDb.Hsapiens.v81.v21

    ## Re-use the GenenameFilter
    where(gnf, mhdb)

    ## Get all mature miRNAs that could be encoded in a common primary transcript.
    matmirnas(mhdb, filter=gnf)

  #+END_SRC

+ miRNA target genes: =mirtarbase= package
  (https://github.com/jotsetung/mirtarbase), bases on data from miRTarBase
  (http://mirtarbase.mbc.nctu.edu.tw/).
+ All miRNA-target gene interactions (MTIs) for all species derived from
  literature.
+ Imports all filter classes from =ensembldb= and =mirhostgenes=.
+ _Example_: get all miRNAs targeting SKA2 and all target genes of miR-301a-3p.

  #+NAME: other-packages-mirtarbase
  #+BEGIN_SRC R
    ####
    ## Load the mirtarbase library providing validated target genes
    library(mirtarbase)

    ## Target genes are categorized by 'Support type'
    listSupportTypes(mirtarbase)

    ## Re-use the GenenameFilter
    where(gnf, mirtarbase)

    ## Get all miRNA-target gene interactions for SKA2.
    miRs <- mtis(mirtarbase, filter=gnf)
    miRs

    ## What miRNAs have been shown to regulate SKA2?
    matmirna(miRs)

  #+END_SRC

+ Both packages are still in development.






