---
title: "Building and Using Ensembl-based Annotation Packages with ensembldb"
author: "Johannes Rainer"
date: "June 26, 2016"
output:
  ioslides_presentation:
    css: style.css
    widescreen: false
---
<style scoped>
ul > li:before {
    color: #1a81c2;
    vertical-align: middle;
    font-family: "Arial Black";
    font-weight: 900;
    margin-left: -.85em;
}
</style>

# Building and Using Ensembl-based Annotation Packages with `ensembldb`

**Johannes Rainer** (EURAC), BioC 2016 Stanford

Clone me @GitHub: <http://github.com/jotsetung/Bioc2016-ensembldb>.

## Introduction

-  `TxDb` objects from `GenomicFeatures` provide gene model annotations:
     - Used for RNA-seq, CHiP-seq, etc.
     - Providing mostly UCSC annotations.

-  `ensembldb` package defines the `EnsDb` class:
     - Same functionality as `TxDb` objects, __plus__:
     - Designed for Ensembl: __all__ genes, attributes _gene biotype_ and _tx biotype_.
     - Allows to query specific annotations using a simple __filter framework__.


## Usage: Query gene, transcript, exon information

-   Available methods to extract data:
    -   `genes`
    -   `transcripts`
    -   `transcriptsBy`
    -   `exons`
    -   `exonsBy`
    -   `cdsBy`
    -   `fiveUTRsByTranscripts`
    -   `threeUTRsByTranscripts`


----

**Example**: get all genes' annotations.

```{r message=FALSE}
## Load an EnsDb package matching Ensembl version 81
library(EnsDb.Hsapiens.v81)
edb <- EnsDb.Hsapiens.v81

## Now just get all genes
genes(edb)
```


----

**Example**: get all genes encoded on chromosome Y.

```{r }
## Define a chromsome filter for Y.
sf <- SeqnameFilter("Y")

## Retrieve the data
genes(edb, filter=sf)
```

## Available filters

* For genes:
    +   `GeneidFilter`
    +   `GenenameFilter`
    +   `EntrezidFilter`
    +   `GenebiotypeFilter`
* For transcripts:
    +   `TxidFilter`
    +   `TxbiotypeFilter`
* For exons:
    +   `ExonidFilter`
    +   `ExonrankFilter`

## Available filters

- _Generic_ filters:
    -   `SeqnameFilter`
    -   `SeqstrandFilter`
    -   `SeqstartFilter`
    -   `SeqendFilter`
    -   `GRangesFilter`: condition can be _within_ or _overlapping_.

- Multiple filters are combined with a logical _AND_.
- Each filter supports 1:n values and also a _like_ condition.

----

__Example__: combine filters.

```{r }
## Example for a GRangesFilter; condition could be "within" or "overlapping"
grf <- GRangesFilter(GRanges(17, IRanges(59000000, 59200000)), condition="within")

## Combine with a GenebiotypeFilter to get all genes except pre-miRNAs and snRNAs.
genes(edb, filter=list(grf, GenebiotypeFilter(c("miRNA", "snRNA"), condition="!=")))
```


## `ensembldb` and the `AnnotationDbi` API

-   `EnsDb` support all `AnnotationDbi` methods **with filters**.
-   __Example__: use `AnnotationDbi`'s `select` method to fetch annotation.

```{r }
## Get all data for the gene SKA2
Res <- select(edb, keys="SKA2", keytype="GENENAME")
head(Res, n=3)
```

---- 

... continued.

```{r }
## What keytypes can be used?
keytypes(edb)

```

----

- Use filters to have more control on the query.

```{r }
## For the gene SKA2, get all exons except exon 1 and 2 for all tx targeted
## for nonsense mediated decay.
select(edb, keys=list(GenenameFilter("SKA2"),
                      ExonrankFilter(1:2, condition="!="),
                      TxbiotypeFilter("nonsense_mediated_decay")))
```



## Annotation for feature counting

-   `exonsBy`: provide gene model information for feature counting.
-   __Example__: get gene models for `GenomicAlignments`' `summarizeOverlaps` method.

```{r eval=FALSE}
library(GenomicAlignments)
library(BiocParallel)
## Get exons by gene, for chromosomes 1:22, X, Y, excluding locus reference 
## genomic genes (LRG)
exns <- exonsBy(edb, by="gene", filter=list(SeqnameFilter(c(1:22, "X", "Y")), 
                                            GeneidFilter("ENSG%", "like")))

bfl <- BamFileList(dir("data/bam", pattern=".bam$", full.names=TRUE), asMates=TRUE, 
                   yieldSize=1e+6, obeyQname=TRUE)
## Define a ScanBamParam with a mapping quality filter.
sbp <- ScanBamParam(mapqFilter=30)

## Do the gene counting
geneCounts <- bplapply(bfl, FUN=summarizeOverlaps, features=exns, mode="IntersectionStrict", 
                       ignore.strand=TRUE, singleEnd=FALSE, fragments=TRUE, param=sbp)
geneCounts <- do.call(cbind, geneCounts)
```

----

-   __Example__: gene models for `Rsubread`'s `featureCount`.

```{r eval=FALSE}
## Convert the exon list to SAF format
saf <- toSAF(exns)

####
##  Do the feature counting using the Rsubread package
library(Rsubread)
bamf <- dir("data/bam", pattern=".bam$", full.names=TRUE)
cnts <- featureCounts(files=bamf, annot.ext=saf, isPairedEnd=TRUE, nthreads=1)
```

## Integrating UCSC and Ensembl annotations

-   UCSC and Ensembl use different chromosome naming styles.
-   __Example__: How to integrate Ensembl based annotations with UCSC data?

```{r message=FALSE}
## Get chromosome names; they are different from UCSC style (chr1, ...)
head(seqlevels(edb))

## Get genes on chromsome Y, UCSC style:
genes(edb, filter=SeqnameFilter("chrY"))

```


----

... continued.

```{r message=FALSE}
## Solution: change the chromosome naming style of the EnsDb:
seqlevelsStyle(edb) <- "UCSC"

genes(edb, filter=SeqnameFilter("chrY"))

```

----

-   __Use case__: get SKA2 tx sequences using BSgenome.

```{r message=FALSE, warning=FALSE}
library(BSgenome.Hsapiens.UCSC.hg38)

ska2tx <- exonsBy(edb, by="tx", filter=GenenameFilter("SKA2"))
extractTranscriptSeqs(BSgenome.Hsapiens.UCSC.hg38, ska2tx)

```

- __Preferred way__: get the `FaFile` corresponding to the correct genome build using the dedicated `getGenomeFaFile` method.

```{r message=FALSE, warning=FALSE}
faf <- getGenomeFaFile(edb)
seqlevelsStyle(edb) <- "Ensembl"
extractTranscriptSeqs(faf, exonsBy(edb, by="tx", filter=GenenameFilter("SKA2")))
```

## Plotting support

-   `ggbio` and `Gviz`: plot data along genomic coordinates.
-   `ggbio`: support for `EnsDb` objects __and filters__ integrated:

```{r ggbio-plot, fig.align='center', width=8, height=3.5, message=FALSE, warning=FALSE}
library(ggbio)
## Plot all genes encoded in the same region than SKA2:
ska2 <- genes(edb, filter=GenenameFilter("SKA2"))
## Plot the genomic region; we're using the gene name as labels for the transcripts.
autoplot(edb, GRangesFilter(ska2, condition="overlapping"), names.expr="gene_name")
```


----

- `Gviz`: `getGeneRegionTrackForGviz` to extract `Gviz`-formatted data.

```{r gviz-plot, fig.align='center', width=8, height=3.5, message=FALSE}
library(Gviz)
## Get a GRanges /formatted/ for Gviz.
grt <- getGeneRegionTrackForGviz(edb, filter=GRangesFilter(ska2, condition="overlapping"))
## Plot the chromosomal region.
plotTracks(list(GenomeAxisTrack(), GeneRegionTrack(grt)), transcriptAnnotation="symbol", 
           chromosome=seqlevels(ska2))
```


## The `ensembldb` shiny app

-   The `ensembldb` shiny app allows interactive annotation look-up.
-   __Example__: search for a gene using the shiny app and return the result to R.

```{r eval=FALSE}
## Run the shiny app:
Result <- runEnsDbApp()

## Inspect the result:
Result
```


## Building annotation databases

### The easiest way: with `AnnotationHub`

-   `ensDbFromAH`: build an `EnsDb` from an `AnnotationHub` (gtf) resource.

```{r message=FALSE}
library(AnnotationHub)
ah <- AnnotationHub()
## Query for available Ensembl gtf files for release 83
query(ah, pattern=c("ensembl", "release-83", "gtf"))
```


----

... continued.

```{r message=FALSE}
## Select one; in this case: Anolis carolinensis (lizard).
edbSql83 <- ensDbFromAH(ah=ah["AH7537"])
db <- EnsDb(edbSql83)  ## Load the database

genes(db, filter=SeqnameFilter("2"))
```

----

### The easy way: from gtf and gff files

-   `ensDbFromGtf`: create an `EnsDb` from a *gtf* or *gff* file.
-   *Should* work with all gtf and gff files from Ensembl.
-   Note: gtf files don't provide the Entrez IDs.
-   __Example__: create an `EnsDb` from a GTF file downloaded from <ftp://ftp.ensembl.org>.

```{r message=FALSE, results='hide'}
## Create the SQLite database file:
##  o Eventually define 'organism' and 'genomeVersion'.
##  o Needs also an internet connection to retrieve the 'seqlengths'.
edbSql <- ensDbFromGtf("data/gtf/Canis_familiaris.CanFam3.1.84.gtf.gz")

```

----

... continued.

```{r }
## Use the makeEnsembldbPackage to create a package, or load and use it.
dogDb <- EnsDb(edbSql)
## Fully functional, except we don't have Entrez gene ids.
head(genes(dogDb, filter=SeqnameFilter("X")))
```

----

### The hard way: using Ensembl's Perl API

-   Requires:
    -   Perl.
    -   Ensembl Perl API (and Bioperl).

-   `fetchTablesFromEnsembl` to fetch the annotations from Ensembl.
-   `makeEnsemblSQLiteFromTables` to create the SQLite database from the tables.
-   `makeEnsembldbPackage` to create a package containing and providing the annotation.

----

-   __Example__: create an `EnsDb` using the Perl API.

```{r eval=FALSE}
## This takes quite some time...
fetchTablesFromEnsembl(version="81", ensemblapi="/Users/jo/ensembl/81/API/ensembl/modules", 
                       species="dog")

## Create an SQLite database from the generated txt files
dbf <- makeEnsemblSQLiteFromTables()

## Finally, create the package
makeEnsembldbPackage(ensdb=dbf, version="1.0.0", author="Johannes Rainer", 
                     maintainer="Johannes Rainer <johannes.rainer@eurac.edu>")
```

----


##  {.flexbox .vcenter}

<dic class="centered">
__Thank you for your attention!__
</div>